<!DOCTYPE html>

<html>
<head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <link href="favicon.ico" rel="shortcut icon">

  <title>Mobile Robots (EMOR) tutorials</title>
  <link href="style.css" rel="stylesheet">
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
</head>

<body>
  <div class="page">

    <div class="heading_body">
      <div style="text-align:left; font-size:160%;">
        <strong>Mobile Robots (EMOR)</strong> tutorials.
      </div>
    </div>

    <div class="content_body">
      <div id="menu">
        <a class="top" href="index.html">TRS</a>
        <a href="setup.html">Setup</a>
	<a href="project1.html">Project 1</a>
	<a href="project2.html">Project 2</a>
	<a href="project3.html">Project 3</a>
	        <a class="submenu" href="project3.html#description">Description</a>
	<a href="api.html">API Documentation</a>
	<a href="tips.html">Tips & Tricks</a>
	<a href="troubleshooting.html">Troubleshooting</a>
      </div>

      <div class="content">
      
<a id="description" name="description"></a>
<h1 style="margin-top: 0">Description</h1>

<p>The goal of the third EMOR tutorial is to write a program enabling youBot to <b>navigate</b>.
This task is broken into three subtasks:
<ol>
  <li>generation of random, yet collision-less trajectory (without any destination)</li>
  <li>navigation to the destination without the use of map</li>
  <li>using map for planning of a colision-less trajectory to the destination</li>
</ol>

<p>Similarly to the previous tutorial, you should write your program on the basis of <code>exercise03.m</code> script, by modifying the section between the
<b>% EMOR exercise begin</b> and <b>% EMOR exercise end</b> comments.

<p>And analogically, we also prepared a simulation environment in V-REP stored in file <code>exercise03.ttt</code>.
<b>You must run it before running your matlab script</b>.


<p>The environment used for this task (presented on the left side) was generated from the binary image, with white pixels representing obstacles (presented on the right).
The image is of size 30px x 30px, whereas the map is of size 15m x 15m.
<p>
<img style="border: 1px solid black; height: 250px" src="raster/tut_03_env.png" alt="env" />

<img style="border: 1px solid black; height: 250px" src="raster/tut_03_map.png" alt="map" />



<h2>Task requirements - generation of random trajectory</h2>

You should write a program that:
<ol>
  <li> Moves the robot ahead (i.e. along the same orientation) until some of obstacles are near (e.g. in a distance smaller than 0.5m) </li>
  <li> Randomly selects new the orientation (e.g. from (30, 330) degrees) </li>
  <li> Rotates the robot so his orientation is the same as the randomly chosen one and starts to move ahead (enters the state from the first point)</li>
</ol>
As a result the robot should randomly "visit" different parts of the map, without colliding with obstacles.


<h2>Task requirements - navigation to the place of destination with Bug2</h2>

Write a program implementing the Bug2 algorithm. The basic idea is to move along the line connecting the target and initial point and in the case of being near to the obstacle follow its contour and thus circumnavigate it.
The program should work as follows:
<ol>
  <li> Find the line connecting initial and target position </li>
  <li> Rotate towards the goal </li>
  <li> Move towards the goal until reaching an obstacle </li>
  <li> Use "following the wall" algorith to avoid the obstacje and depart immediately when it is able to move directly toward the goal (when crosses the "original" line once again). </li>
</ol>


<h2>Task requirements - planning with Global dynamic window</h2>
This algorithm is responsible for finding the optimal route to the goal in the planning phase, i.e. before leaving the initial pose.
For this purpose it analyses the map generates the path and in an off-line manner.
When finished, the robot simply follows the generated path.
The generation of the path works as follows:
<ol>
  <li> Set the cost of target position (cell) to 0 </li>
  <li> For a given neighbouring cell find the cell with lowest cost lc, set cost of the currently analysed cell to lc+1 </li>
  <li> Repeat step 2 for each cell until all cells (including the initial one) have assigned costs </li>
  <li> Find the path starting from the initial cell to the destination, by selecting the neighbouring cell with smallest cost</li>
</ol>



<h2 style="margin-top: 0">Grading</h2>
<ol>
  <li>Generation of a random trajectory (2p), including:</li>
	<ol>
  	<li>Moving the robot ahead  until an obstacle enters the "dangerous zone" (1p)</li>
  	<li>Random selection of new orientation and rotating the robot (1p)</li>
	</ol>

  <li>Navigation to the place of destination with Bug2 (5p)</li>
	<ol>
  	<li>User input of the goal position (x,y) (1p)</li>
  	<li>Implementation of the Bug2 algorithm (3p)</li>
  	<li>Dynamic visualization of the realized path point by point (1p)</li>
	</ol>

  <li>Planning with Global dynamic window (6p)</li>
	<ol>
  	<li>Loading and proper "rescaling" the map from map.png file (1p)</li>
  	<li>User input of the goal position (x,y), with validation whether it is accessible (1p)</li>
  	<li>Implementation of the "Global dynamic window"-based generation of trajectory (2p)</li>
  	<li>Drawing the generated trajectory in the  (1p)</li>
  	<li>Realization of the trajectory (1p)</li>
	</ol>

</ol>


<p><b>Important:</b> You must modify only the indicated section of the <code>exercise03.m</code> script. Modification of other parts of the code are forbidden and will result in zero points from the project. 


<h2>Programming hints</h2>

The motion of the robot should be controlled by variables representing the relative velocities:
<ol>
  <li><code>forwBackVel</code> - linear velocity along the x axis of the robot [m/s] </li>
  <li><code>leftRightVel</code> - linear velocity along the y axis of the robot [m/s] </li>
  <li><code>rotVel</code> - angular velocity around the z axis of the robot [rad/s] </li>
</ol>

Additionally, you should gather and analyse data from the lidar sensors. There are two variables returned by the function:
<ol>
  <li><code>pts</code> - a table containing readings i.e. contact points,  in sensor's coordinates, each expressed as [x;y;z] </li>
  <li><code>contacts</code> - a table of values <0/1> determining whether an obstactle was detected or the reading corresponds to the maximal sensor range (in this case it is set to 5m) </li>
</ol>




</div>
      <div class="trailer_body">
        <div style="width: 100%; display: table;">
          <div style="display: table-row">
            <div style="width: 50%; display: table-cell; vertical-align: bottom;">
              Valid <a href="http://validator.w3.org/check?uri=referer">HTML5</a> and <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a>
            </div>

            <div style="width: 50%; display: table-cell; text-align: right; vertical-align: bottom;">
              &copy; Renaud Detry 2014<br>
              This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
